# Пошук найкоротшого шляху між двома точками поверхні

## Структура проєкту
Загалом ми написали 5 функцій для проєкту:

  read_matrix_from_csv - приймає аргумент file_path - шлях до файлу в виді стрічки(str), зчитує матрицю з файлу з csv розширенням, та повертає матрицю використовуючи функції бібліотеки numpy

  calculate_distance - приймає два аргументи: - вираховує відстань за теоремою Піфагора
    height_diff - різницю висот двох вершин
    step - крок між двома вершинами

  heuristic - приймає три аргументи: - знаходить евристичну відстань між двома вершинами, а саме відстань між індексами вершин
    node - початкова вершина
    end - кінцева вершина
    step - крок

  get_neighbors - приймає чотири аргументи: - знаходить індекси сусідів вершин, яку приймає на вхід, та повертає список сусідів
    x - координата вершини по вісі x
    y - координата вершини по вісі y
    rows - к-сть рядків матриці
    cols - к-сть стовпців матриці

  shortest_path - приймає чотири аргументи: є пошуком найкоротшого шляху, тобто імплементацією алгоритму А*
    M - матриця, яку ми отримуємо з функції read_matrix_from_csv
    step - крок між вершинами
    A - початкова вершина
    B - кінцева вершина

## Використані алгоритми, принципи дискретної математики
Для виконання проєкту ми використали алгоритм A* ( A-star ).\
Цей алгоритм можна розглядати як доповнення до алгоритму Дейкстри, але на відміну від алгоритму Дейкстри він шукає відстань лише від початкової вершини до кінцевої, а не шукає найкоротші шляхи до кожної вершини графу
Для більшої продуктивності алгоритму ми використали евристичну відстань. \
Через свою повноту, оптимальність і оптимальну ефективність алгоритм A* часто використовують в багатьох галузях інформатики, особливо в іграх.\
Незважачи на те, що він є найкращим для застосування, у нього є один великий недолік - його просторова складність O(b^d), оскільки він зберігає всі згенеровані вершини в пам'яті. Таким чином, у практичних системах маршрутизації він зазвичай перевершує алгоритми, які можуть попередньо обробляти граф для досягнення кращої продуктивності, а також підходи, що використовують обмежену пам'ять.\

## Використані бібліотеки

Для виконання комп'ютерного проєкту ми імпортували кілька бібліотек:\
  Бібліотека heapq — допомогла нам в реалізації алгоритму черги купи та пріоритетної черги\
  Бібліотека numpy — використали для швидших математичних операцій. Також наша матриця це масив нампай, оскільки вони займають менше пам'яті, і до них можна використовувати методи з бібліотеки нампай, що прискорює роботу.\
  Бібліотека pandas — використали задля швидкого читання матриці й лаконічної реалізації самого читання й простого перетворення на масив\
  Бібліотека numba — JIT-компілятор, що перетворює код пайтон на оптимізований машинний код, зокрема використали для прискорення операцій з numpy\

## Процес виконання

## Розподіл роботи
  Стасишин Анна - Реалізація коду \
  Надія Федій - Презентація до проєкту \
  Павлосюк Роман - документація до проєкту \
  Нагорний Ростислав - Візуалізація проєкту \
  Цибух Андріана - Візуалізація проєкту
