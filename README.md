# Пошук найкоротшого шляху між двома точками поверхні

## Структура проєкту
Загалом ми написали 5 функцій для проєкту:<br>

1. read_matrix_from_csv - приймає аргумент:
    * file_path - шлях до файлу<br>

    Зчитує матрицю з файлу з csv розширенням, та повертає матрицю використовуючи функції бібліотеки numpy

<br>

2) calculate_distance - приймає два аргументи: - Вираховує відстань за теоремою Піфагора
    * height_diff - різницю висот двох вершин<br>
    * step - крок між двома вершинами

    Вираховує відстань за теоремою Піфагора

<br>

3) heuristic - приймає три аргументи:
    * node - початкова вершина<br>
    * end - кінцева вершина<br>
    * step - крок

    Знаходить евристичну відстань між двома вершинами, а саме відстань між індексами вершин

<br>

4) get_neighbors - приймає чотири аргументи:
    * x - координата вершини по вісі x<br>
    * y - координата вершини по вісі y<br>
    * rows - к-сть рядків матриці<br>
    * cols - к-сть стовпців матриці<br>
    
    Знаходить індекси сусідів вершин, яку приймає на вхід, та повертає список сусідів

<br>

5) shortest_path - приймає чотири аргументи:
    * M - матриця, яку ми отримуємо з функції read_matrix_from_csv<br>
    * step - крок між вершинами<br>
    * A - початкова вершина<br>
    * B - кінцева вершина<br>
    
    Є пошуком найкоротшого шляху, тобто імплементацією алгоритму А*

<br>

## Використані алгоритми, принципи дискретної математики
Для виконання проєкту ми використали алгоритм **_A_*** ( A-star ).<br>
Цей алгоритм можна розглядати як доповнення до алгоритму _Дейкстри_, але на відміну від нього він шукає відстань **лише** від початкової вершини до кінцевої, а не шукає найкоротші шляхи до кожної вершини графу.<br>
Для більшої продуктивності алгоритму ми використали евристичну відстань. <br>
Через свою повноту, оптимальність і оптимальну ефективність алгоритм A* часто використовують в багатьох галузях інформатики, особливо в іграх.<br>
Незважачи на те, що він є найкращим для застосування, у нього є один великий недолік - його просторова складність **_O(b^d)_**, оскільки він зберігає всі згенеровані вершини в пам'яті. Таким чином, у практичних системах маршрутизації він зазвичай перевершує алгоритми, які можуть попередньо обробляти граф для досягнення кращої продуктивності, а також підходи, що використовують обмежену пам'ять.<br>
З допомогою бібліотеки heapq ми змогли зменшити складність алгоритму до O(nlogn)<br>
## Використані бібліотеки

Для виконання комп'ютерного проєкту ми імпортували кілька бібліотек:<br>
* Бібліотека heapq — допомогла нам в реалізації алгоритму черги купи та пріоритетної черги<br>
* Бібліотека numpy — використали для швидших математичних операцій. Також наша матриця це масив нампай, оскільки вони займають менше пам'яті, і до них можна використовувати методи з бібліотеки нампай, що прискорює роботу.<br>
* Бібліотека pandas — використали задля швидкого читання матриці й лаконічної реалізації самого читання й простого перетворення на масив.<br>
* Бібліотека numba — JIT-компілятор, що перетворює код пайтон на оптимізований машинний код, зокрема використали для прискорення операцій з numpy.<br>

## Розподіл роботи, враження від виконання
*Стасишин Анна - Реалізація коду<br>*
*Надія Федій - Презентація до проєкту<br>*
*Павлосюк Роман - документація до проєкту<br>*
*Нагорний Ростислав - Візуалізація проєкту<br>*
*Цибух Андріана - Візуалізація проєкту*
